@* @implements IDisposable

<div class="column @Column.StyleClass @GetEditModeClass()"  >
    @if (Column.Rows.Any())
    {
        <BdfRows Rows="@Column.Rows"  />
    }
    else if (editModeService.EditMode)
    {
        <SortableList Group="bdf" 
                      Items="Column.Widgets" 
                      Context="widget" 
                      OnRemove="OnRemoveWidget" 
                      OnUpdate="OnUpdateWidget" 
                      Handle=".drag-handle"
                      Id="@Column.ColumnId">
            <SortableItemTemplate>
                <div style="width: 100%; height: 100%;">
                    <BdfWidget Widget="@widget" OnDeleteWidget="DeleteWidgetInstance" />
                </div>
            </SortableItemTemplate>
        </SortableList>
    }
    else
    {
        @foreach (var widget in Column.Widgets)
        {
            <BdfWidget Widget="@widget" />
        }
    }
</div>

@code {
    [CascadingParameter] Dashboard dashboard { get; set; } = default!;
    [Parameter, EditorRequired] public Column Column { get; set; } = default!;
    [Parameter] public EventCallback<Column> ColumnChanged { get; set; }
    [Parameter] public bool IsPreview { get; set; } = false;
    [Inject] public EditModeService editModeService { get; set; } = default!;


    protected override void OnInitialized()
    {
        base.OnInitialized();
        editModeService.EditModeChanged += OnEditModeChanged;
        Column.WidgetsChanged += OnWidgetsChanged;
    }

    private async void OnEditModeChanged(object? sender, EventArgs e)
    {
        await InvokeAsync(() => StateHasChanged());
    }

    private async void OnWidgetsChanged(object? sender, List<WidgetInstance> e)
    {
        await InvokeAsync(() => StateHasChanged());
    }

    private string GetEditModeClass()
    {
        return editModeService.EditMode ? "edit" : string.Empty;
    }

    public void Dispose()
    {
        editModeService.EditModeChanged -= OnEditModeChanged;
        Column.WidgetsChanged -= OnWidgetsChanged;
    }

    private async Task DeleteWidgetInstance(WidgetInstance widgetInstance)
    {
        var instance = Column.Widgets.FirstOrDefault(x => x.WidgetInstanceId == widgetInstance.WidgetInstanceId);
        if (instance != null)
        {
            Column.Widgets.Remove(instance);
            await ColumnChanged.InvokeAsync(Column);
        }
    }

    private async void OnRemoveWidget((int oldIndex, int newIndex, string fromId, string toId) indices)
    {
        // // get the item at the old index in list 1
        // var item = items1[indices.oldIndex];

        // // add it to the new index in list 2
        // items2.Insert(indices.newIndex, item);

        // // remove the item from the old index in list 1
        // items1.Remove(items1[indices.oldIndex]);
        dashboard.MoveWidget(indices.oldIndex, indices.newIndex, indices.fromId, indices.toId);
        await ColumnChanged.InvokeAsync(Column);
        await InvokeAsync(() => StateHasChanged());
    }

    private async void OnUpdateWidget((int oldIndex, int newIndex, string fromId, string toId) indices)
    {
        // // deconstruct the tuple
        // var (oldIndex, newIndex) = indices;

        // var items = this.items;
        // var itemToMove = items[oldIndex];
        // items.RemoveAt(oldIndex);

        // if (newIndex < items.Count)
        // {
        //     items.Insert(newIndex, itemToMove);
        // }
        // else
        // {
        //     items.Add(itemToMove);
        // }
        dashboard.MoveWidget(indices.oldIndex, indices.newIndex, indices.fromId, indices.toId);
        await ColumnChanged.InvokeAsync(Column);
        await InvokeAsync(() => StateHasChanged()); 
    }
}
 *@